<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>System Status</title>
  <link rel="stylesheet" href="./assets/base.css?v=20251214" />
  <link rel="stylesheet" href="./assets/feature3.css?v=20260216" />
</head>
<body class="fit-viewport">
  <section id="feature3" class="panel fit-section">
    <!-- Row 1: CPU & GPU Usage -->
    <div class="stats-row">
      <div class="stat-card">
        <div class="stat-label">CPU Usage</div>
        <div class="stat-bar-track"><div id="barCpu" class="stat-bar"></div></div>
        <div class="stat-value" id="valCpu">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">GPU Usage <span id="gpuName" class="stat-sub"></span></div>
        <div class="stat-bar-track"><div id="barGpu" class="stat-bar"></div></div>
        <div class="stat-value" id="valGpu">—</div>
      </div>
    </div>

    <!-- Row 2: CPU & GPU Temp -->
    <div class="stats-row">
      <div class="stat-card">
        <div class="stat-label">CPU Temp</div>
        <div class="stat-value stat-value-lg" id="valCpuTemp">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">GPU Temp</div>
        <div class="stat-value stat-value-lg" id="valGpuTemp">—</div>
      </div>
    </div>

    <!-- Row 3: RAM & VRAM -->
    <div class="stats-row">
      <div class="stat-card">
        <div class="stat-label">RAM Usage</div>
        <div class="stat-bar-track"><div id="barRam" class="stat-bar"></div></div>
        <div class="stat-value" id="valRam">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">VRAM Usage</div>
        <div class="stat-bar-track"><div id="barVram" class="stat-bar"></div></div>
        <div class="stat-value" id="valVram">—</div>
      </div>
    </div>

    <!-- Row 4: Title + Disks -->
    <div class="stats-row-title-disk">
      <h2 class="stats-title">System Status <span id="statusDot" class="dot dot-waiting"></span></h2>
      <div id="diskGrid" class="stats-row stats-row-wrap"></div>
    </div>

    <!-- History Section -->
    <div class="history-section">
      <div class="history-header">
        <button id="btnToggleHistory" class="btn-history">Show History</button>
        <button id="btnClearHistory" class="btn-history btn-history-clear" style="display:none">Clear History</button>
        <div id="rangeWrap" class="range-wrap" style="display:none">
          <label for="rangeSlider" class="range-label" id="rangeLabel">All</label>
          <input id="rangeSlider" type="range" min="0" max="8" value="8" class="range-slider" />
        </div>
        <span id="historyInfo" class="history-info"></span>
      </div>
      <div id="chartsWrap" class="charts-wrap" style="display:none"></div>
    </div>

    <p id="statsError" class="stats-error" style="display:none"></p>
  </section>

  <script>
    (function () {
      const POLL_MS = 2000;
      const STORE_KEY = 'sysHistory';
      // ~16 MB budget → ~80 000 entries (each ~200 bytes JSON with all fields)
      const MAX_ENTRIES = 80000;

      /* ── DOM refs ── */
      const section  = document.getElementById('feature3');
      const dot       = document.getElementById('statusDot');
      const barCpu    = document.getElementById('barCpu');
      const barRam    = document.getElementById('barRam');
      const barGpu    = document.getElementById('barGpu');
      const barVram   = document.getElementById('barVram');
      const valCpu    = document.getElementById('valCpu');
      const valRam    = document.getElementById('valRam');
      const valGpu    = document.getElementById('valGpu');
      const valVram   = document.getElementById('valVram');
      const valCpuT   = document.getElementById('valCpuTemp');
      const valGpuT   = document.getElementById('valGpuTemp');
      const gpuName   = document.getElementById('gpuName');
      const diskGrid  = document.getElementById('diskGrid');
      const errBox    = document.getElementById('statsError');

      const btnToggle   = document.getElementById('btnToggleHistory');
      const btnClear    = document.getElementById('btnClearHistory');
      const chartsWrap  = document.getElementById('chartsWrap');
      const hInfo       = document.getElementById('historyInfo');
      const rangeWrap   = document.getElementById('rangeWrap');
      const rangeSlider = document.getElementById('rangeSlider');
      const rangeLabel  = document.getElementById('rangeLabel');

      /* Time-range presets (in ms); last entry = show all */
      const RANGE_PRESETS = [
        { label: '5 min',  ms: 5 * 60000 },
        { label: '15 min', ms: 15 * 60000 },
        { label: '30 min', ms: 30 * 60000 },
        { label: '1 hr',   ms: 60 * 60000 },
        { label: '2 hr',   ms: 2 * 3600000 },
        { label: '6 hr',   ms: 6 * 3600000 },
        { label: '12 hr',  ms: 12 * 3600000 },
        { label: '24 hr',  ms: 24 * 3600000 },
        { label: 'All',    ms: Infinity },
      ];
      function filterHistory(hist) {
        const preset = RANGE_PRESETS[parseInt(rangeSlider.value, 10)] || RANGE_PRESETS[3];
        rangeLabel.textContent = preset.label;
        if (!hist.length || preset.ms === Infinity) return hist;
        const cutoff = Date.now() - preset.ms;
        return hist.filter(e => e.t >= cutoff);
      }

      let chartVisible = false;
      // Track disk card elements keyed by mountpoint
      let diskCardEls = {};
      // Set of currently visible disk mountpoints (e.g. 'C:\\')
      let activeDiskMounts = new Set();

      /* ── Helpers ── */
      function setBar(el, v) {
        el.style.width = (v != null ? v : 0) + '%';
        el.classList.toggle('bar-warn', v >= 60 && v < 85);
        el.classList.toggle('bar-crit', v >= 85);
      }
      function tempStr(v) {
        if (v == null) return 'N/A';
        return v.toFixed(1) + ' °C';
      }

      /* ── History (localStorage) ── */
      function loadHistory() {
        try { const r = localStorage.getItem(STORE_KEY); return r ? JSON.parse(r) : []; }
        catch { return []; }
      }
      function saveHistory(arr) {
        if (arr.length > MAX_ENTRIES) arr = arr.slice(arr.length - MAX_ENTRIES);
        try { localStorage.setItem(STORE_KEY, JSON.stringify(arr)); } catch { /* quota */ }
        return arr;
      }
      function pushEntry(d) {
        const hist = loadHistory();
        const entry = {
          t: Date.now(),
          cpu: d.cpu_percent,
          ram: d.ram_percent,
          ramU: d.ram_used_gb,
          ramT: d.ram_total_gb,
          gpu: d.gpu_percent,
          vram: d.vram_percent,
          cpuT: d.cpu_temp_c,
          gpuT: d.gpu_temp_c,
        };
        // Store each disk's percent keyed by mountpoint: d_C:\, d_D:\, d_/, …
        if (d.disks) {
          for (const dk of d.disks) {
            entry['d_' + dk.mountpoint] = dk.percent;
          }
        }
        hist.push(entry);
        return saveHistory(hist);
      }
      function updateInfo(hist) {
        if (!hist.length) { hInfo.textContent = ''; return; }
        const spanMs = hist[hist.length - 1].t - hist[0].t;
        const hrs = (spanMs / 3600000).toFixed(1);
        const kb = (JSON.stringify(hist).length / 1024).toFixed(0);
        hInfo.textContent = hist.length + ' pts \u00b7 ' + hrs + ' h span \u00b7 ~' + kb + ' KB stored';
      }

      /* ── Chart definitions ── */
      const CHART_COLORS = {
        cpu:  { line: '#007aff', fill: 'rgba(0,122,255,0.10)' },
        ram:  { line: '#34c759', fill: 'rgba(52,199,89,0.10)' },
        gpu:  { line: '#af52de', fill: 'rgba(175,82,222,0.10)' },
        vram: { line: '#ff6482', fill: 'rgba(255,100,130,0.10)' },
        cpuT: { line: '#ff3b30', fill: 'rgba(255,59,48,0.10)' },
        gpuT: { line: '#ff9500', fill: 'rgba(255,149,0,0.10)' },
        disk: { line: '#5856d6', fill: 'rgba(88,86,214,0.10)' },
      };

      // Returns chart layout as rows of [left, right?] pairs, matching the stat card layout
      function buildChartRows(hist) {
        if (!hist.length) return [];
        const last = hist[hist.length - 1];
        const rows = [];

        // Row 1: CPU Usage + GPU Usage
        const cpuCfg = { key: 'cpu', label: 'CPU Usage %', yMax: 100, unit: '%', color: CHART_COLORS.cpu, getValue: e => e.cpu };
        const gpuCfg = last.gpu != null
          ? { key: 'gpu', label: 'GPU Usage %', yMax: 100, unit: '%', color: CHART_COLORS.gpu, getValue: e => e.gpu }
          : null;
        rows.push([cpuCfg, gpuCfg]);

        // Row 2: CPU Temp + GPU Temp (always shown)
        const cpuTCfg = { key: 'cpuT', label: 'CPU Temp °C', yMax: 110, unit: '°C', color: CHART_COLORS.cpuT, getValue: e => e.cpuT };
        const gpuTCfg = { key: 'gpuT', label: 'GPU Temp °C', yMax: 110, unit: '°C', color: CHART_COLORS.gpuT, getValue: e => e.gpuT };
        rows.push([cpuTCfg, gpuTCfg]);

        // Row 3: RAM + VRAM
        const ramCfg = { key: 'ram', label: 'RAM Usage %', yMax: 100, unit: '%', color: CHART_COLORS.ram, getValue: e => e.ram };
        const vramCfg = last.vram != null
          ? { key: 'vram', label: 'VRAM Usage %', yMax: 100, unit: '%', color: CHART_COLORS.vram, getValue: e => e.vram }
          : null;
        rows.push([ramCfg, vramCfg]);

        // Row 3+: Disk charts — only for currently mounted disks
        const diskCfgs = [...activeDiskMounts].sort().map(mp => {
          const dk = 'd_' + mp;
          return {
            key: dk,
            label: 'Disk ' + mp + ' %',
            yMax: 100,
            unit: '%',
            color: CHART_COLORS.disk,
            getValue: e => e[dk],
          };
        });
        for (let i = 0; i < diskCfgs.length; i += 2) {
          rows.push([diskCfgs[i], diskCfgs[i + 1] || null]);
        }

        return rows;
      }

      /* ── Generic canvas line chart ── */
      function drawLineChart(canvas, hist, cfg, chartH) {
        const H = chartH || 180;
        if (!hist.length) {
          // Draw empty placeholder with "N/A" label
          const dpr = window.devicePixelRatio || 1;
          const rect = canvas.parentElement.getBoundingClientRect();
          const W = rect.width;
          canvas.width = W * dpr;
          canvas.height = H * dpr;
          canvas.style.width = W + 'px';
          canvas.style.height = H + 'px';
          const ctx = canvas.getContext('2d');
          ctx.scale(dpr, dpr);
          ctx.fillStyle = '#fafafa';
          ctx.fillRect(0, 0, W, H);
          ctx.fillStyle = '#333';
          ctx.font = 'bold 11px system-ui, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(cfg.label, 52, 16);
          ctx.fillStyle = '#bbb';
          ctx.font = '14px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('N/A', W / 2, H / 2 + 5);
          return;
        }

        // Check if all values are null for this metric
        const hasData = hist.some(e => cfg.getValue(e) != null);
        if (!hasData) {
          const dpr = window.devicePixelRatio || 1;
          const rect = canvas.parentElement.getBoundingClientRect();
          const W = rect.width;
          canvas.width = W * dpr;
          canvas.height = H * dpr;
          canvas.style.width = W + 'px';
          canvas.style.height = H + 'px';
          const ctx = canvas.getContext('2d');
          ctx.scale(dpr, dpr);
          ctx.fillStyle = '#fafafa';
          ctx.fillRect(0, 0, W, H);
          ctx.fillStyle = '#333';
          ctx.font = 'bold 11px system-ui, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(cfg.label, 52, 16);
          ctx.fillStyle = '#bbb';
          ctx.font = '14px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data available', W / 2, H / 2 + 5);
          return;
        }

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        const W = rect.width;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        const PAD_L = 48, PAD_R = 14, PAD_T = 24, PAD_B = 32;
        const plotW = W - PAD_L - PAD_R;
        const plotH = H - PAD_T - PAD_B;
        const yMax = cfg.yMax;

        // bg
        ctx.fillStyle = '#fafafa';
        ctx.fillRect(0, 0, W, H);

        // Y grid
        ctx.strokeStyle = '#e8e8e8';
        ctx.lineWidth = 1;
        ctx.font = '10px system-ui, sans-serif';
        ctx.fillStyle = '#999';
        ctx.textAlign = 'right';
        const ySteps = cfg.yMax <= 110 ? 4 : 5;
        for (let i = 0; i <= ySteps; i++) {
          const val = (yMax / ySteps) * i;
          const y = PAD_T + plotH - (val / yMax) * plotH;
          ctx.beginPath(); ctx.moveTo(PAD_L, y); ctx.lineTo(PAD_L + plotW, y); ctx.stroke();
          ctx.fillText(Math.round(val) + (cfg.unit === '%' ? '%' : ''), PAD_L - 5, y + 3);
        }

        // X labels
        const tMin = hist[0].t, tMax = hist[hist.length - 1].t;
        const tSpan = tMax - tMin || 1;
        ctx.textAlign = 'center';
        ctx.fillStyle = '#999';
        const ticks = Math.min(5, hist.length);
        for (let i = 0; i <= ticks; i++) {
          const ratio = i / ticks;
          const x = PAD_L + ratio * plotW;
          const d = new Date(tMin + ratio * tSpan);
          ctx.fillText(d.getHours().toString().padStart(2, '0') + ':' + d.getMinutes().toString().padStart(2, '0'), x, H - 6);
        }

        // Line & Fill — break at gaps larger than the expected sample spacing
        const step = hist.length > 1500 ? Math.floor(hist.length / 1500) : 1;
        const GAP_THRESH = POLL_MS * step * 1.5;

        // Build segments: arrays of {x, y} split by gaps or null values
        const segments = [];
        let seg = [];
        let prevT = null;
        for (let i = 0; i < hist.length; i += step) {
          const v = cfg.getValue(hist[i]);
          if (v == null) {
            if (seg.length) { segments.push(seg); seg = []; }
            prevT = null;
            continue;
          }
          const t = hist[i].t;
          const x = PAD_L + ((t - tMin) / tSpan) * plotW;
          const y = PAD_T + plotH - (Math.min(v, yMax) / yMax) * plotH;
          if (prevT != null && (t - prevT) > GAP_THRESH) {
            if (seg.length) { segments.push(seg); seg = []; }
          }
          seg.push({ x, y });
          prevT = t;
        }
        if (seg.length) segments.push(seg);

        // Draw each segment's stroke and fill independently
        const baseY = PAD_T + plotH;
        ctx.strokeStyle = cfg.color.line;
        ctx.lineWidth = 1.5;
        ctx.lineJoin = 'round';
        for (const s of segments) {
          ctx.beginPath();
          ctx.moveTo(s[0].x, s[0].y);
          for (let j = 1; j < s.length; j++) ctx.lineTo(s[j].x, s[j].y);
          ctx.stroke();
          ctx.lineTo(s[s.length - 1].x, baseY);
          ctx.lineTo(s[0].x, baseY);
          ctx.closePath();
          ctx.fillStyle = cfg.color.fill;
          ctx.fill();
        }

        // Title
        ctx.fillStyle = '#333';
        ctx.font = 'bold 11px system-ui, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(cfg.label, PAD_L + 4, 16);
      }

      /* ── Build / redraw all charts in rows ── */
      function renderAllCharts(hist) {
        const rows = buildChartRows(hist);
        chartsWrap.innerHTML = '';

        // Use visualViewport for zoom-aware sizing, fallback to innerHeight
        const viewH = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
        // Measure actual top offset of chartsWrap after clearing
        const wrapRect = chartsWrap.getBoundingClientRect();
        const topOffset = wrapRect.top;
        const rowGap = 14;
        const totalGaps = (rows.length - 1) * rowGap;
        const border = rows.length * 2; // 1px border top+bottom per chart-box
        const available = viewH - topOffset - totalGaps - border - 8; // 8px bottom breathing room
        const chartH = Math.max(48, Math.floor(available / rows.length));

        for (const [leftCfg, rightCfg] of rows) {
          const row = document.createElement('div');
          row.className = 'charts-row';
          chartsWrap.appendChild(row);

          // Left slot
          if (leftCfg) {
            const box = document.createElement('div');
            box.className = 'chart-box';
            const cvs = document.createElement('canvas');
            box.appendChild(cvs);
            row.appendChild(box);
            drawLineChart(cvs, hist, leftCfg, chartH);
          } else {
            row.appendChild(document.createElement('div'));
          }

          // Right slot
          if (rightCfg) {
            const box = document.createElement('div');
            box.className = 'chart-box';
            const cvs = document.createElement('canvas');
            box.appendChild(cvs);
            row.appendChild(box);
            drawLineChart(cvs, hist, rightCfg, chartH);
          } else {
            row.appendChild(document.createElement('div'));
          }
        }
      }

      /* ── Dynamic disk cards ── */
      function updateDiskCards(disks) {
        if (!disks || !disks.length) {
          // All disks gone — clear everything
          for (const mp of Object.keys(diskCardEls)) {
            diskCardEls[mp].card.remove();
            delete diskCardEls[mp];
          }
          activeDiskMounts.clear();
          return;
        }
        const seen = new Set();
        for (const dk of disks) {
          seen.add(dk.mountpoint);
          let els = diskCardEls[dk.mountpoint];
          if (!els) {
            const card = document.createElement('div');
            card.className = 'stat-card';
            card.innerHTML =
              '<div class="stat-label">Disk <span class="stat-sub"></span></div>' +
              '<div class="stat-bar-track"><div class="stat-bar"></div></div>' +
              '<div class="stat-value">\u2014</div>';
            diskGrid.appendChild(card);
            els = {
              card: card,
              label: card.querySelector('.stat-sub'),
              bar: card.querySelector('.stat-bar'),
              val: card.querySelector('.stat-value'),
            };
            diskCardEls[dk.mountpoint] = els;
          }
          els.label.textContent = dk.device + ' (' + dk.mountpoint + ') — ' + dk.fstype;
          setBar(els.bar, dk.percent);
          els.val.textContent = dk.used_gb.toFixed(1) + ' / ' + dk.total_gb.toFixed(1)
            + ' GB (' + dk.percent.toFixed(1) + ' %) — ' + dk.free_gb.toFixed(1) + ' GB free';
        }
        // Remove cards for disks that disappeared
        for (const mp of Object.keys(diskCardEls)) {
          if (!seen.has(mp)) {
            diskCardEls[mp].card.remove();
            delete diskCardEls[mp];
          }
        }
        activeDiskMounts = seen;
      }

      /* ── Toggle / clear ── */
      btnToggle.addEventListener('click', function () {
        chartVisible = !chartVisible;
        chartsWrap.style.display = chartVisible ? '' : 'none';
        btnClear.style.display = chartVisible ? '' : 'none';
        rangeWrap.style.display = chartVisible ? '' : 'none';
        btnToggle.textContent = chartVisible ? 'Hide History' : 'Show History';
        section.classList.toggle('compact', chartVisible);
        if (chartVisible) {
          const h = loadHistory();
          const fh = filterHistory(h);
          updateInfo(fh);
          renderAllCharts(fh);
        }
      });
      rangeSlider.addEventListener('input', function () {
        if (!chartVisible) return;
        const h = loadHistory();
        const fh = filterHistory(h);
        updateInfo(fh);
        renderAllCharts(fh);
      });
      btnClear.addEventListener('click', function () {
        if (confirm('Clear all stored history?')) {
          localStorage.removeItem(STORE_KEY);
          chartsWrap.innerHTML = '';
          hInfo.textContent = 'History cleared.';
        }
      });

      /* ── Poll ── */
      async function poll() {
        try {
          const res = await fetch('/api/system-stats', { credentials: 'same-origin' });
          if (res.status === 401 || res.status === 403) {
            errBox.textContent = 'Admin access required.';
            errBox.style.display = '';
            return;
          }
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const d = await res.json();

          errBox.style.display = 'none';
          dot.className = 'dot dot-ok';

          setBar(barCpu, d.cpu_percent);
          valCpu.textContent = d.cpu_percent != null ? d.cpu_percent.toFixed(1) + ' %' : 'N/A';

          setBar(barRam, d.ram_percent);
          valRam.textContent = d.ram_percent != null
            ? d.ram_used_gb.toFixed(1) + ' / ' + d.ram_total_gb.toFixed(1) + ' GB (' + d.ram_percent.toFixed(1) + ' %)'
            : 'N/A';

          setBar(barGpu, d.gpu_percent);
          valGpu.textContent = d.gpu_percent != null ? d.gpu_percent.toFixed(1) + ' %' : 'N/A';
          gpuName.textContent = d.gpu_name ? '(' + d.gpu_name + ')' : '';

          setBar(barVram, d.vram_percent);
          if (d.vram_percent != null) {
            const usedGb = (d.vram_used_mb / 1024).toFixed(1);
            const totalGb = (d.vram_total_mb / 1024).toFixed(1);
            valVram.textContent = usedGb + ' / ' + totalGb + ' GB (' + d.vram_percent.toFixed(1) + ' %)';
          } else {
            valVram.textContent = 'N/A';
          }

          valCpuT.textContent = tempStr(d.cpu_temp_c);
          valGpuT.textContent = tempStr(d.gpu_temp_c);

          // Dynamic disk cards
          updateDiskCards(d.disks);

          // Store history
          const hist = pushEntry(d);
          if (chartVisible) {
            const fh = filterHistory(hist);
            updateInfo(fh);
            renderAllCharts(fh);
          }
        } catch (e) {
          dot.className = 'dot dot-err';
          errBox.textContent = 'Failed to fetch stats: ' + e.message;
          errBox.style.display = '';
        }
      }

      function onResize() {
        if (chartVisible) renderAllCharts(filterHistory(loadHistory()));
      }
      window.addEventListener('resize', onResize);
      if (window.visualViewport) window.visualViewport.addEventListener('resize', onResize);

      poll();
      setInterval(poll, POLL_MS);
    })();
  </script>
  <script src="./assets/read_only.js?v=20251222"></script>
</body>
</html>
